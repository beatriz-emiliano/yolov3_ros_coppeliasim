<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Strict//EN">
<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<title>The main script</title>
<link rel="stylesheet" type="text/css" href="../style.css">
</head>

<body>

<div align="center">
<table class=allEncompassingTable >
 <tr>
  <td >
<p><a href="../index.html" TARGET="_top"><img src="images/homeImg.png"></a></p>



<h1>The main script <img src="images/mainScript1.jpg"></h1>

<p>A main script is a <a href="simulationScripts.htm">simulation script</a>. By default, each <a href="scenes.htm">scene</a> in CoppeliaSim will have one main script. It contains the basic code that allows a <a href="simulation.htm">simulation</a> to run. Without main script, a running simulation won't do anything.</p>

<p>The main script contains a collection of <a href="callbackFunctions.htm">callbacks functions</a> that are appropriately called by the system. Except for the initialization callback, all other callbacks are optional. The default main script is typically segmented in 4  callback functions: </p>


<li>the initialization function: <strong>sysCall_init</strong>. This callback function is not optional. It will be executed one time just at the beginning of a simulation. The code is in charge of preparing a simulation, etc.<br>
</li>

<li>the actuation function: <strong>sysCall_actuation</strong>. This callback function will be executed in each simulation pass. The code is in charge of handling all the actuation functionality of the simulation. One command is of particular interest: <a href="regularApi/simHandleChildScripts.htm">sim.handleChildScripts</a>, which calls <a href="childScripts.htm">child scripts'</a> <em>sysCall_actuation</em> callback functions. Without that commands, <a href="childScripts.htm">child scripts</a> won't execute, or won't execute their actuation function, and specific <a href="models.htm">model</a> functionality or behavior won't operate as intended.  <br>
</li>

<li>the sensing function: <strong>sysCall_sensing</strong>. This callback function will be executed in each simulation pass. The code is in charge of handling all the sensing functionality of the simulation (<a href="proximitySensors.htm">proximity sensors</a>, etc.) in a generic way. One command is of particular interest:<a href="regularApi/simHandleChildScripts.htm"> sim.handleChildScripts</a>, which  calls <a href="childScripts.htm">child scripts'</a> <em>sysCall_sensing</em> callback functions. Without that commands, <a href="childScripts.htm">child scripts</a> won't  execute their sensing function, and specific <a href="models.htm">model</a> functionality or behavior won't operate as intended.<br>
</li>

<li>the restoration function: <strong>sysCall_cleanup</strong>. This function will be executed one time just before a simulation ends. The code is in charge of restoring <a href="objects.htm">object's</a> initial configuration, clearing sensor states, etc.<br>
</li>

<p>
Following is the typical main script, slightly simplified:
</p>

<code class="hljs language-lua coppelia-coppeliasim-script">
function <strong>sysCall_init</strong>()
    -- Initialization part:
end

function <strong>sysCall_actuation</strong>()
    -- Actuation part:
    sim.handleChildScripts(sim.syscb_actuation)
    sim.handleCustomizationScripts(sim.syscb_actuation)
    sim.handleAddOnScripts(sim.syscb_actuation)
    sim.handleSandboxScript(sim.syscb_actuation)
    sim.handleJointMotion()
    sim.handleDynamics(sim.getSimulationTimeStep())
end

function <strong>sysCall_sensing</strong>()
    -- Sensing part:
    sim.handleSensingStart()
    sim.handleProximitySensor(sim.handle_all_except_explicit)
    sim.handleVisionSensor(sim.handle_all_except_explicit)
    sim.handleChildScripts(sim.syscb_sensing)
    sim.handleCustomizationScripts(sim.syscb_sensing)
    sim.handleAddOnScripts(sim.syscb_sensing)
    sim.handleSandboxScript(sim.syscb_sensing)
end

function <strong>sysCall_cleanup</strong>()
    -- Clean-up part:
    sim.handleChildScripts(sim.syscb_cleanup)
    sim.resetProximitySensor(sim.handle_all_except_explicit)
    sim.resetVisionSensor(sim.handle_all_except_explicit)
end

function <strong>sysCall_suspend</strong>()
    sim.handleChildScripts(sim.syscb_suspend)
    sim.handleCustomizationScripts(sim.syscb_suspend)
    sim.handleAddOnScripts(sim.syscb_suspend)
    sim.handleSandboxScript(sim.syscb_suspend)
end

function <strong>sysCall_suspended</strong>()
    sim.handleChildScripts(sim.syscb_suspended)
    sim.handleCustomizationScripts(sim.syscb_suspended)
    sim.handleAddOnScripts(sim.syscb_suspended)
    sim.handleSandboxScript(sim.syscb_suspended)
end

function <strong>sysCall_resume</strong>()
    sim.handleChildScripts(sim.syscb_resume)
    sim.handleCustomizationScripts(sim.syscb_resume)
    sim.handleAddOnScripts(sim.syscb_resume)
    sim.handleSandboxScript(sim.syscb_resume)
end</code>

<p>There are however many more <a href="callbackFunctions.htm#systemCallbacks">system callback functions</a> the main script can use to react to various events.</p>

<p>The main script is not supposed to be modified. The reason for this is following: one of CoppeliaSim's strength is that any <a href="models.htm">model</a> (robot, actuator, sensor, etc) can be copied into a <a href="scenes.htm">scene</a> and is immediately operational. When modifying the main script, you run the risk that models won't perform as expected anymore (e.g. if your main script lacks the command sim.handleChildScripts then all models copied into the scene won't operate at all). Another reason is that keeping a default main script allows old scenes to easily adjust for new functionality (e.g. if a new CoppeliaSim version introduces a neat command sim.doMagic(), then old scenes will automatically be updated to have that command also called in their main script).<br>
</p>

<p>If however, for a reason or another you really need to modify the main script of a scene, you can do this by double-clicking the light-red script icon next to the world icon at the top of the <a href="userInterface.htm#SceneHierarchy">scene hierarchy</a>:<br>
</p>




<p align=center><img src="images/mainScript1.jpg"></p>
<p class=imageLabel>[Main script icon]</p>
<br>

<p>Most of child script's system callback functions are called from the main script, via the <a href="regularApi/simHandleChildScripts.htm">sim.handleChildScripts</a> function, which <a href="scriptExecution.htm">operates in a cascading fashion</a> upon the scene hierarchy and the child scripts attached to  individual scene object. </p>
<p>If you look at the default main script, you can notice that the actuation function allows actuating or modifying the scene content (e.g. sim.handleDynamics, etc.), while the sensing function allows sensing and probing the scene content (e.g. sim.handleProximitySensor, etc.). Following illustrates what happens in the default main script when a mobile robot equipped with a <a href="proximitySensors.htm">proximity sensor</a> is simulated:<br>
</p>


<p align=center><img src="images/mainScript3.jpg"></p>
<p class=imageLabel>[Default actuation - sensing - display sequence]</p>
<br>


<p>With above's sequence in mind, <a href="childScripts.htm">child scripts</a> will always read (with <a href="regularApi/simReadProximitySensor.htm">sim.readProximitySensor</a>) the proximity sensor's state from previous sensing (which happened at the end of previous simulation pass, inside of the main script, with <a href="regularApi/simHandleProximitySensor.htm">sim.handleProximitySensor</a>), then react to obstacles.</p>
<p>If you need to explicitely handle a sensor, then make sure to always do it while in the sensing section, otherwise you might end-up with situations where the display appears wrong as illustrated in following figure:<br>
</p>
<p align=center><img src="images/mainScript4.jpg"></p>
<p class=imageLabel>[Sensing - actuation - display sequence]</p>
<br>

<p>As does the main script have an actuation-sensing sequence, so do <a href="childScripts.htm">child scripts</a>.</p>
<br>
<br>
 </tr>
</table> 
</div>  
  
  
</body>

</html>
